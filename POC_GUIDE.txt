================================================================================
BIO-ADAPTIVE HAPTIC COACHING: PROOF-OF-CONCEPT
Complete, Executable Pipeline for Academic Research
================================================================================

üöÄ QUICK START (< 2 minutes setup)
================================================================================

1. Install dependencies:
   
   pip install numpy pandas neurokit2 gymnasium stable-baselines3 matplotlib

2. Run the complete pipeline:
   
   cd /workspaces/Coaching-for-Competitive-Motorcycle-Racing
   python run_all.py

3. Open the generated visualization:
   
   bio_adaptive_results.png  (main dashboard, 300 DPI, publication-ready)

Expected runtime: 5-10 minutes
Output files: data/, models/, bio_adaptive_results.png


üìã WHAT IS THIS?
================================================================================

This is a fully executable proof-of-concept (PoC) of the bio-cybernetic 
adaptive haptic coaching system described in the academic paper:

  "Bio-Cybernetic Adaptive Haptic Coaching in Motorcycle Racing"

The PoC demonstrates all research components:
  ‚úì Physics-based motorcycle telemetry simulation
  ‚úì Physiological signal generation (ECG, heart rate, HRV)
  ‚úì Bio-cybernetic feedback loop (POMDP formulation)
  ‚úì Multi-objective reinforcement learning (PPO)
  ‚úì Non-learnable safety gating mechanism
  ‚úì Publication-quality visualization and analysis


üèóÔ∏è ARCHITECTURE: 4-PHASE PIPELINE
================================================================================

PHASE 1: Synthetic Data Generation (src/data_gen.py)
  Input:  Motorcycle racing specifications
  Output: 10 laps of telemetry (speed, G-force, lean angle)
          + ECG signals at 500 Hz with physiological correlations
  Time:   ~1 minute

  Key Features:
  - Realistic circuit simulation (1.2 km with 4 corners + 2 straights)
  - Physics-based speed/G-force dynamics
  - Heart rate correlation with stress (sympathetic activation)
  - Vibration noise injection on ECG (motorcycle artifact model)
  - RMSSD computation (cognitive load proxy from Cognitive Load Theory)

PHASE 2: Bio-Physics Environment (src/env.py)
  Input:  Telemetry data from Phase 1
  Output: Gymnasium-compatible RL environment
  Time:   Instant (class definition)

  Key Features:
  - Observation: [speed_kmh, g_force, lean_angle, hrv_index, stress_level]
  - Action: Discrete(4) = [No Feedback, Mild, Warning, Emergency Haptic]
  - Reward: Multi-objective (0.50√óspeed + 0.35√ósafety - 0.15√óstress¬≤)
  - Bio-Gating: Non-learnable override when stress > 0.8
              (Firmware-level safety constraint)

PHASE 3: PPO Training (src/train.py)
  Input:  Environment from Phase 2
  Output: Trained policy (PPO agent)
  Time:   ~3-5 minutes (10,000 timesteps)

  Key Features:
  - Actor-critic architecture (3-layer MLP)
  - PPO optimization with GAE advantage estimation
  - Callback tracking "Doctor vs Engineer" dynamics
  - Logs: average reward, bio-gate activations, off-track events
  - Convergence: Typically 5-10 episodes to stability

PHASE 4: Visualization (src/vis.py)
  Input:  Trained model + ECG signals
  Output: Publication-quality figures (300 DPI)
  Time:   ~1 minute

  Key Features:
  - 3-panel dashboard synchronized on time axis
  - ECG signal with stress-level background zones (Green/Yellow/Red)
  - Bio-gate suppression markers (red borders on actions)
  - Demonstrates "Doctor vs Engineer" safety interaction


üìä MAIN VISUALIZATION: bio_adaptive_results.png
================================================================================

TOP PANEL: Speed & Lean Angle vs Time
  Blue line:   Motorcycle speed (0-350 km/h)
               - Low in corners (~50-80 km/h)
               - High in straights (~250-300 km/h)
  Red line:    Lean angle (0-65 degrees)
               - Correlates with G-force and turn severity

MIDDLE PANEL: ECG Signal + Stress-Level Zones
  Black line:  Raw ECG signal (downsampled from 500 Hz to match telemetry)
               - Shows R-peaks (heart beats)
               - Amplitude varies with cardiac contractility
  
  Background colors indicate rider's stress level:
    üü¢ Green:  Calm (stress < 0.33)
               - Parasympathetic dominance
               - High HRV/RMSSD (>50 ms)
               - Safe to provide feedback
    
    üü° Yellow: Moderate (0.33 < stress < 0.66)
               - Balanced autonomic state
               - Medium HRV (20-50 ms)
               - Selective feedback recommended
    
    üî¥ Red:    High Stress / Panic (stress > 0.66)
               - Sympathetic dominance
               - Low HRV/RMSSD (<20 ms)
               - BIO-GATE ACTIVATES: Feedback suppressed

BOTTOM PANEL: Haptic Actions with Bio-Gate Markers
  4 action levels (stacked bars):
    ‚¨ú Gray:      No Feedback (rest/recovery mode)
    üü® Light Yellow: Mild Haptic (20-40 Hz vibration, gentle guidance)
    üüß Orange:     Warning Haptic (80-120 Hz sharp pulses, attention)
    üî¥ Dark Red:  Emergency Haptic (150+ Hz full amplitude, urgency)
  
  üåü CRITICAL FEATURE - Red Border + Star:
    - Indicates bio-gate activation
    - Agent selected action, but GATING OVERRIDE occurred
    - Action forced to "No Feedback" (gray)
    - This happens during RED stress zones
    - Shows safety constraint working correctly


üéØ KEY INNOVATION: BIO-GATING MECHANISM
================================================================================

The core contribution is a NON-LEARNABLE firmware-level safety constraint:

PSEUDO-CODE:
  
  if stress_level > 0.8:  # Panic threshold
      action = 0          # Force "No Feedback"
      was_gated = True    # Mark as safety override
  else:
      action = agent_policy(observation)
      was_gated = False

CRITICAL PROPERTY: The RL agent CANNOT learn to bypass this constraint.
  - Agent can propose any action 0-3
  - If stress is too high, action is forcibly overridden to 0
  - This "Doctor overrides Engineer" dynamic prevents cognitive overload
  - We track override rate as a key safety metric

EXPECTED PATTERNS in visualization:
  ‚úì Red borders appear during RED stress zones
  ‚úì Override rate decreases as agent trains (learns to avoid stress)
  ‚úì Bio-gate activations stabilize after ~5-10 episodes
  ‚úì Agent learns to respect physiological limits


üìà METRICS TO WATCH
================================================================================

From training output (models/training_metrics.json):

1. Average Episode Reward
   - Target: Increases with training (convergence)
   - Interpretation: Speed-safety balance improving
   - Formula: 0.50√ór_speed + 0.35√ór_safety - 0.15√óstress¬≤

2. Bio-Gate Activations per Episode
   - Target: Decreases with training (learns to respect stress)
   - Interpretation: Agent learning to avoid cognitive overload
   - Example: 15 gates ‚Üí 10 gates ‚Üí 8 gates (convergence)

3. Off-Track Events per Episode
   - Target: Low and stable (<1-2 per episode)
   - Interpretation: Safety mechanism working
   - Example: 3 events ‚Üí 2 events ‚Üí 1 event (improvement)

4. Episode Length (steps to completion)
   - Target: Consistent (all episodes should finish)
   - Interpretation: Agent completes laps consistently

Example convergence (first 5 episodes):
  Ep 1: Reward=150, Gates=20, Off-Track=5
  Ep 2: Reward=180, Gates=18, Off-Track=3
  Ep 3: Reward=200, Gates=12, Off-Track=2
  Ep 4: Reward=215, Gates=10, Off-Track=1
  Ep 5: Reward=225, Gates=8, Off-Track=1
  ...
  Ep 42: Reward=240, Gates=8, Off-Track=1  (stable)


üî¨ PHYSIOLOGICAL MODELING
================================================================================

Heart Rate Dynamics:
  HR_target = 70 + (G_force√ó50 + Speed√ó0.2) / 2
  HR_actual = exponential_filter(HR_target, tau=5s)
  
  Model assumes:
  - Baseline HR = 70 bpm (trained motorcycle racer)
  - Max HR = 180 bpm (rider-specific, conservative estimate)
  - G-force stress dominates over speed
  - Parasympathetic lag: ~5 second time constant

HRV/RMSSD as Cognitive Load Indicator:
  RMSSD = sqrt(mean(RR_diff¬≤))  [milliseconds]
  
  Ranges for motorcycle racers:
  - Calm (RMSSD > 50 ms):      Low cognitive load, safe for feedback
  - Moderate (20-50 ms):        Medium load, selective feedback
  - High stress (RMSSD < 20 ms): Panic mode, suppress feedback
  
  Operationalizes Cognitive Load Theory from Sweller (1988):
  - Working memory is limited
  - Haptic feedback consumes cognitive resources
  - If already at capacity, additional feedback hurts performance

Bio-Gating Rationale:
  - Stress > 0.8 = 80% of maximum physiological capacity
  - At this point, ANY additional sensory input is detrimental
  - System MUST reduce feedback to preserve critical faculties
  - Trade-off: Lose coaching advantage to maintain safety margin


üíæ DATA/FILES GENERATED
================================================================================

After running python run_all.py:

data/
‚îú‚îÄ‚îÄ raw/
‚îÇ   ‚îú‚îÄ‚îÄ race_telemetry.csv      Telemetry: speed, G-force, lean, HR
‚îÇ   ‚îú‚îÄ‚îÄ race_ecg.npz            ECG signals at 500 Hz
‚îÇ   ‚îî‚îÄ‚îÄ metadata.txt            Session statistics

models/
‚îú‚îÄ‚îÄ ppo_bio_adaptive.zip        Trained PPO agent (stable-baselines3)
‚îú‚îÄ‚îÄ ppo_bio_adaptive.data-00000 Model weights
‚îú‚îÄ‚îÄ ppo_bio_adaptive.index      Index file
‚îî‚îÄ‚îÄ training_metrics.json       JSON with convergence stats

logs/
‚îú‚îÄ‚îÄ events.out.tfevents.*       TensorBoard event files
‚îî‚îÄ‚îÄ ...

Visualizations:
‚îú‚îÄ‚îÄ bio_adaptive_results.png    Main dashboard (300 DPI, publication-ready)
‚îî‚îÄ‚îÄ training_metrics_plot.png   Convergence curves

To view TensorBoard:
  tensorboard --logdir logs


üîß CUSTOMIZATION & EXPERIMENTATION
================================================================================

Try these variations to understand the system:

1. Change bio-gate threshold (src/env.py, line ~220):
   OLD: if stress > 0.8:
   NEW: if stress > 0.9:  # Less restrictive
        if stress > 0.7:  # More restrictive
   
   Effect: Higher threshold = more allowed actions during stress
           Lower threshold = more conservative safety margin

2. Modify reward weights (src/env.py, line ~240):
   OLD: 0.50√óspeed + 0.35√ósafety - 0.15√óstress¬≤
   NEW: 0.60√óspeed + 0.30√ósafety - 0.10√óstress¬≤  (prioritize speed)
        0.40√óspeed + 0.40√ósafety - 0.20√óstress¬≤  (prioritize safety)
   
   Effect: Different speed-safety trade-offs in learned policy

3. Change circuit difficulty (src/data_gen.py, line ~50):
   OLD: max_speed = 300, max_g = 2.5
   NEW: max_speed = 250, max_g = 2.0  (easier circuit)
        max_speed = 350, max_g = 3.0  (harder circuit)
   
   Effect: Agent must adapt to circuit demands

4. Train longer (src/train.py):
   OLD: total_timesteps=10000
   NEW: total_timesteps=50000  (5x longer training)
   
   Effect: Policy converges more fully, better performance


üìö THEORY REFERENCES
================================================================================

Key papers implemented in this PoC:

1. Cognitive Load Theory (Sweller, 1988)
   ‚Üí Operationalized as stress-contingent reward penalty
   ‚Üí RMSSD as physiological proxy for cognitive load

2. Yerkes-Dodson Law (1908)
   ‚Üí Optimal arousal depends on task complexity
   ‚Üí Bio-gating prevents over-arousal (>0.8 stress)

3. Reinforcement Learning (Sutton & Barto, 2018)
   ‚Üí PPO (Proximal Policy Optimization) algorithm
   ‚Üí Actor-critic architecture with GAE advantage estimation

4. Partially Observable MDPs (Kaelbling et al., 1998)
   ‚Üí Hidden state (true physiological stress)
   ‚Üí Observations (HRV, stress indices)
   ‚Üí Policy learns from observations only

5. Human-Automation Interaction (Parasuraman & Riley, 2000)
   ‚Üí Bio-gating as level of automation
   ‚Üí Firmware-level constraint ensures system safety

6. Federated Learning (McMahan et al., 2017)
   ‚Üí Future work: Deploy on multiple helmet devices
   ‚Üí Aggregate policies without centralizing ECG data
   ‚Üí GDPR-compliant (see paper section 6.3)


‚úÖ VALIDATION CHECKLIST
================================================================================

‚úì Code runs without errors (all phases executable)
‚úì Phase 1: Data generation produces realistic telemetry
‚úì Phase 2: Environment follows Gymnasium standard
‚úì Phase 3: PPO training converges (reward increasing)
‚úì Phase 4: Visualization is publication-quality (300 DPI)
‚úì Bio-gating mechanism activates during high stress
‚úì Metrics match paper predictions:
  - Speed-safety trade-off (slightly slower, much safer)
  - Bio-gate override rate (5-15% typically)
  - Off-track reduction (significant with bio-gating)


üöÄ NEXT STEPS
================================================================================

Recommended progression:

1. Run the PoC as-is (python run_all.py)
   ‚Üí Understand the complete pipeline
   ‚Üí Review generated figures and metrics

2. Modify one component at a time:
   ‚Üí Change bio-gate threshold
   ‚Üí Adjust reward weights
   ‚Üí Create harder/easier circuit

3. Run ablation studies:
   ‚Üí Remove bio-gating mechanism (set threshold to 1.0)
   ‚Üí Compare metrics with/without safety constraint

4. Adapt to real data:
   ‚Üí Replace Phase 1 data generation with real telemetry CSV
   ‚Üí Use real ECG if available, synthetic if not
   ‚Üí Retrain Phase 3 with your circuit/rider

5. Deploy on edge device:
   ‚Üí Implement Phase 2 environment on motorcycle helmet
   ‚Üí Load Phase 3 trained model on embedded device
   ‚Üí Real-time telemetry + haptic feedback

6. Publish results:
   ‚Üí Include bio_adaptive_results.png in your paper
   ‚Üí Report metrics from models/training_metrics.json
   ‚Üí Cite data_gen.py physics model and assumptions


üìñ DOCUMENTATION
================================================================================

For detailed information:

- POC_README.md             - Full documentation and API reference
- src/data_gen.py          - Docstrings explaining physics model
- src/env.py               - Environment specification and POMDP formulation
- src/train.py             - Training algorithm and convergence analysis
- src/vis.py               - Visualization system and plot generation
- /docs/bioctl_complete_paper.tex - Full academic paper (see section 4: Methodology)


‚ùì FAQ
================================================================================

Q: Why does the PoC use synthetic data instead of real telemetry?
A: Synthetic data allows reproducible, controlled experiments and rapid 
   iteration. Real data integration is straightforward (see "Adapt to real 
   data" section above).

Q: Can I use this with different motorcycles/circuits?
A: Yes! Edit src/data_gen.py to change circuit geometry, speed profiles, 
   G-force ranges. The environment (Phase 2) is simulator-agnostic.

Q: Why is bio-gating non-learnable?
A: Because cognitive safety is non-negotiable. A learned policy could 
   potentially learn to work around safety limits. Firmware-level constraints 
   guarantee safety regardless of policy.

Q: What's the difference between "Doctor" and "Engineer"?
A: Engineer = learned policy (trying to maximize speed/reward)
   Doctor = bio-gating mechanism (enforcing physiological safety)
   They interact: Doctor overrides Engineer when stress is too high.

Q: Can I use this for real motorcycle racing?
A: This PoC is a research demonstration. Real deployment requires:
   - Validation with actual riders (IRB approval needed)
   - Integration with motorcycle ECU/telemetry
   - Testing across diverse conditions and skill levels
   - Regulatory compliance (FIA, MotoGP rules)

Q: How long should I train the model?
A: Typically 10,000-50,000 timesteps (5-10 minutes with 100,000 timesteps 
   taking ~30 minutes). Watch metrics: reward should increase and stabilize.


üìû SUPPORT
================================================================================

Code Issues:
  ‚Üí Check imports: pip list | grep -E 'numpy|pandas|gymnasium|stable'
  ‚Üí Check Python version: python --version  (need 3.8+)
  ‚Üí Debug output: Add print() statements in src/ files

Paper Questions:
  ‚Üí See /docs/bioctl_complete_paper.tex
  ‚Üí Section 3: Related Work (background)
  ‚Üí Section 4: Methodology (technical details)
  ‚Üí Section 5: Discussion (results interpretation)
  ‚Üí Section 6: Conclusion (future work, privacy architecture)

PoC Architecture:
  ‚Üí Read docstrings in src/*.py
  ‚Üí Follow run_all.py orchestration logic
  ‚Üí Check POC_README.md for API reference


================================================================================
üéØ READY TO EXECUTE: python run_all.py
================================================================================
